{
  "version": 3,
  "sources": ["../../@nivo/stream/src/StreamLayer.tsx", "../../@nivo/stream/src/StreamLayers.tsx", "../../@nivo/stream/src/StreamDots.tsx", "../../@nivo/stream/src/StreamSlicesItem.tsx", "../../@nivo/stream/src/StreamSlices.tsx", "../../@nivo/stream/src/props.ts", "../../@nivo/stream/src/StreamDotsItem.tsx", "../../@nivo/stream/src/LayerTooltip.tsx", "../../@nivo/stream/src/StackTooltip.tsx", "../../@nivo/stream/src/Stream.tsx", "../../@nivo/stream/src/hooks.ts", "../../@nivo/stream/src/ResponsiveStream.tsx"],
  "sourcesContent": ["import { useCallback, createElement, MouseEvent } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamLayerData } from './types'\n\ninterface StreamLayerProps<RawDatum extends StreamDatum> {\n    layer: StreamLayerData\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayer = <RawDatum extends StreamDatum>({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayerProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { layer }), event, 'left')\n        },\n        [showTooltipFromEvent, tooltip, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n", "import { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { StreamLayer } from './StreamLayer'\nimport { StreamCommonProps, StreamLayerData, StreamDatum } from './types'\n\ninterface StreamLayersProps<RawDatum extends StreamDatum> {\n    layers: StreamLayerData[]\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayers = <RawDatum extends StreamDatum>({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayersProps<RawDatum>) => (\n    <g>\n        {layers.map((layer, i) => (\n            <StreamLayer<RawDatum>\n                key={i}\n                layer={layer}\n                getBorderColor={getBorderColor}\n                borderWidth={borderWidth}\n                fillOpacity={fillOpacity}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { createElement } from 'react'\nimport { StreamSvgProps, StreamLayerDatum, StreamDatum } from './types'\n\ninterface StreamDotsProps<RawDatum extends StreamDatum> {\n    id: string | number\n    color: string\n    data: StreamLayerDatum[]\n    dotComponent: Exclude<StreamSvgProps<RawDatum>['dotComponent'], undefined>\n    position: 'start' | 'center' | 'end'\n    getSize: (datum: StreamLayerDatum) => number\n    getColor: (datum: StreamLayerDatum) => string\n    getBorderWidth: (datum: StreamLayerDatum) => number\n    getBorderColor: (datum: StreamLayerDatum) => string\n}\n\nconst getDotY = <RawDatum extends StreamDatum>(\n    datum: StreamLayerDatum,\n    position: StreamDotsProps<RawDatum>['position']\n) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nexport const StreamDots = <RawDatum extends StreamDatum>({\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}: StreamDotsProps<RawDatum>) => (\n    <>\n        {data.map((datum, i) => {\n            return createElement(dotComponent, {\n                key: i,\n                datum,\n                x: datum.x,\n                y: getDotY<RawDatum>(datum, position),\n                size: getSize(datum),\n                color: getColor(datum),\n                borderWidth: getBorderWidth(datum),\n                borderColor: getBorderColor(datum),\n            })\n        })}\n    </>\n)\n", "import { createElement, useCallback, useState, MouseEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamSliceData } from './types'\n\ninterface StreamSlicesItemProps<RawDatum extends StreamDatum> {\n    slice: StreamSliceData\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlicesItem = <RawDatum extends StreamDatum>({\n    slice,\n    height,\n    tooltip,\n}: StreamSlicesItemProps<RawDatum>) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            setIsHover(true)\n            showTooltipFromEvent(createElement(tooltip, { slice }), event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n", "import { StreamSliceData, StreamDatum, StreamCommonProps } from './types'\nimport { StreamSlicesItem } from './StreamSlicesItem'\n\ninterface StreamSlicesProps<RawDatum extends StreamDatum> {\n    slices: StreamSliceData[]\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlices = <RawDatum extends StreamDatum>({\n    slices,\n    height,\n    tooltip,\n}: StreamSlicesProps<RawDatum>) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem<RawDatum>\n                key={slice.index}\n                slice={slice}\n                height={height}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { StackOrder, StackOffset, AreaCurve } from '@nivo/core'\nimport { StreamCommonProps, StreamLayerId } from './types'\nimport { StreamDotsItem } from './StreamDotsItem'\nimport { LayerTooltip } from './LayerTooltip'\nimport { StackTooltip } from './StackTooltip'\n\nexport const defaultProps = {\n    label: 'id',\n    order: 'none' as StackOrder,\n    offsetType: 'wiggle' as StackOffset,\n    curve: 'catmullRom' as AreaCurve,\n    axisTop: null,\n    axisRight: null,\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n    colors: { scheme: 'nivo' } as StreamCommonProps<any>['colors'],\n    fillOpacity: 1,\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [['darker', 1]],\n    } as StreamCommonProps<any>['borderColor'],\n    enableDots: false,\n    dotPosition: 'center' as StreamCommonProps<any>['dotPosition'],\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n    isInteractive: true,\n    tooltip: LayerTooltip,\n    enableStackTooltip: true,\n    stackTooltip: StackTooltip,\n    legends: [],\n    legendLabel: 'id',\n    role: 'application',\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'] as StreamLayerId[],\n    defs: [],\n    fill: [],\n    animate: true,\n    motionConfig: 'default',\n    role: 'img',\n    isFocusable: false,\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\n\nexport interface StreamDotsItemProps {\n    x: number\n    y: number\n    size: number\n    color: string\n    borderWidth: number\n    borderColor: string\n}\n\nexport const StreamDotsItem = ({\n    x,\n    y,\n    size,\n    color,\n    borderWidth,\n    borderColor,\n}: StreamDotsItemProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n", "import { BasicTooltip } from '@nivo/tooltip'\nimport { TooltipProps } from './types'\n\nexport const LayerTooltip = ({ layer }: TooltipProps) => (\n    <BasicTooltip id={layer.label} enableChip={true} color={layer.color} />\n)\n", "import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { StackTooltipProps } from './types'\n\nexport const StackTooltip = ({ slice }: StackTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.layerId} color={p.color} />,\n                p.layerLabel,\n                p.formattedValue,\n            ]),\n        [slice]\n    )\n\n    return <TableTooltip rows={rows} />\n}\n", "import { createElement, Fragment, ReactNode, forwardRef, Ref, ReactElement } from 'react'\nimport {\n    Container,\n    SvgWrapper,\n    useDimensions,\n    // @ts-expect-error no types\n    bindDefs,\n    WithChartRef,\n} from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { StreamLayers } from './StreamLayers'\nimport { StreamDots } from './StreamDots'\nimport { StreamSlices } from './StreamSlices'\nimport { useStream } from './hooks'\nimport { svgDefaultProps } from './props'\nimport { StreamDatum, StreamLayerId, StreamSvgProps } from './types'\n\ntype InnerStreamProps<RawDatum extends StreamDatum> = Omit<\n    StreamSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n> & {\n    forwardedRef: Ref<SVGSVGElement>\n}\n\nconst InnerStream = <RawDatum extends StreamDatum>({\n    data,\n    keys,\n    label,\n    valueFormat,\n    offsetType,\n    order,\n    curve,\n    layers: chartLayers = svgDefaultProps.layers,\n    width,\n    height,\n    margin: partialMargin,\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n    colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n    enableDots = svgDefaultProps.enableDots,\n    dotPosition = svgDefaultProps.dotPosition,\n    dotComponent = svgDefaultProps.dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    enableStackTooltip = svgDefaultProps.enableStackTooltip,\n    stackTooltip = svgDefaultProps.stackTooltip,\n    legends = svgDefaultProps.legends,\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    forwardedRef,\n}: InnerStreamProps<RawDatum>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    } = useStream<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        label,\n        valueFormat,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    const layerById: Record<StreamLayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        layers: null,\n        dots: null,\n        slices: null,\n        legends: null,\n    }\n\n    if (chartLayers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n            />\n        )\n    }\n\n    if (chartLayers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (chartLayers.includes('layers')) {\n        layerById.layers = (\n            <StreamLayers<RawDatum>\n                key=\"layers\"\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <Fragment key=\"dots\">\n                {layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.data}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {\n        layerById.slices = (\n            <StreamSlices<RawDatum>\n                key=\"slices\"\n                slices={slices}\n                height={innerHeight}\n                tooltip={stackTooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => {\n                    const legendData = layers\n                        .map(layer => ({\n                            id: layer.id,\n                            label: layer.label,\n                            color: layer.color,\n                            fill: layer.fill,\n                        }))\n                        .reverse()\n\n                    return (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legend}\n                            containerWidth={innerWidth}\n                            containerHeight={innerHeight}\n                            data={legendData}\n                        />\n                    )\n                })}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            ref={forwardedRef}\n        >\n            {chartLayers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Stream = forwardRef(\n    <RawDatum extends StreamDatum>(\n        {\n            isInteractive = svgDefaultProps.isInteractive,\n            animate = svgDefaultProps.animate,\n            motionConfig = svgDefaultProps.motionConfig,\n            theme,\n            renderWrapper,\n            ...props\n        }: StreamSvgProps<RawDatum>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container\n            animate={animate}\n            isInteractive={isInteractive}\n            motionConfig={motionConfig}\n            renderWrapper={renderWrapper}\n            theme={theme}\n        >\n            <InnerStream<RawDatum> {...props} isInteractive={isInteractive} forwardedRef={ref} />\n        </Container>\n    )\n) as <RawDatum extends StreamDatum>(\n    props: WithChartRef<StreamSvgProps<RawDatum>, SVGSVGElement>\n) => ReactElement\n", "import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport {\n    usePropertyAccessor,\n    useValueFormatter,\n    useCurveInterpolation,\n    // @ts-expect-error no types\n    stackOrderFromProp,\n    // @ts-expect-error no types\n    stackOffsetFromProp,\n} from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    StreamCommonProps,\n    StreamCustomLayerProps,\n    StreamDataProps,\n    StreamDatum,\n    StreamLayerData,\n    StreamLayerDatum,\n    StreamSliceData,\n} from './types'\nimport { defaultProps } from './props'\nimport { createLinearScale, createPointScale } from '@nivo/scales'\n\nexport const useStream = <RawDatum extends StreamDatum>({\n    width,\n    height,\n    data,\n    keys,\n    label = defaultProps.label,\n    valueFormat,\n    offsetType = defaultProps.offsetType,\n    order = defaultProps.order,\n    curve = defaultProps.curve,\n    colors = defaultProps.colors,\n    borderColor = defaultProps.borderColor,\n    dotSize = defaultProps.dotSize,\n    dotColor = defaultProps.dotColor,\n    dotBorderWidth = defaultProps.dotBorderWidth,\n    dotBorderColor = defaultProps.dotBorderColor,\n}: {\n    width: number\n    height: number\n    data: StreamDataProps<RawDatum>['data']\n    keys: StreamDataProps<RawDatum>['keys']\n    label?: StreamCommonProps<RawDatum>['label']\n    valueFormat?: StreamCommonProps<RawDatum>['valueFormat']\n    offsetType?: StreamCommonProps<RawDatum>['offsetType']\n    order?: StreamCommonProps<RawDatum>['order']\n    curve?: StreamCommonProps<RawDatum>['curve']\n    colors?: StreamCommonProps<RawDatum>['colors']\n    dotSize?: StreamCommonProps<RawDatum>['dotSize']\n    dotColor?: StreamCommonProps<RawDatum>['dotColor']\n    dotBorderWidth?: StreamCommonProps<RawDatum>['dotBorderWidth']\n    dotBorderColor?: StreamCommonProps<RawDatum>['dotBorderColor']\n    borderColor?: StreamCommonProps<RawDatum>['borderColor']\n}) => {\n    const areaCurveFactory = useCurveInterpolation(curve)\n    const areaGenerator = useMemo(\n        () =>\n            area<StreamLayerDatum>()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(areaCurveFactory),\n        [areaCurveFactory]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack<RawDatum, string | number>()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const allMin: number[] = []\n        const allMax: number[] = []\n\n        const layers = stack(data).map(layer => {\n            return layer.map(point => {\n                allMin.push(point[0])\n                allMax.push(point[1])\n\n                return {\n                    ...point,\n                    value: point.data[layer.key] as number,\n                }\n            })\n        })\n\n        const minValue = Math.min(...allMin)\n        const maxValue = Math.max(...allMax)\n\n        const xScale = createPointScale(\n            { type: 'point' },\n            { all: Array.from({ length: data.length }, (_, i) => i), min: 0, max: data.length },\n            width\n        )\n        const yScale = createLinearScale(\n            { type: 'linear', min: minValue },\n            { all: [minValue, maxValue], min: minValue, max: maxValue },\n            height,\n            'y'\n        )\n        return [layers, xScale, yScale]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale<Omit<StreamLayerData, 'label' | 'color' | 'data'>>(\n        colors,\n        'id'\n    )\n    const getBorderColor = useInheritedColor<StreamLayerData>(borderColor, theme)\n\n    const getDotSize = useMemo(\n        () => (typeof dotSize === 'function' ? dotSize : () => dotSize),\n        [dotSize]\n    )\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const getLabel = usePropertyAccessor<\n        Omit<StreamLayerData, 'label' | 'color' | 'data'>,\n        string | number\n    >(label)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const enhancedLayers: StreamLayerData[] = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const computedPoints: StreamLayerDatum[] = points.map((point, i) => ({\n                    layerId: keys[layerIndex],\n                    layerLabel: '',\n                    index: i,\n                    color: '',\n                    x: xScale(i) as number,\n                    value: point.value,\n                    formattedValue: formatValue(point.value),\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                const layer: Omit<StreamLayerData, 'label' | 'color' | 'data'> = {\n                    id: keys[layerIndex] as string,\n                    path: areaGenerator(computedPoints) as string,\n                }\n\n                const layerWithComputedProperties: Omit<StreamLayerData, 'data'> = {\n                    ...layer,\n                    label: getLabel(layer),\n                    color: getColor(layer),\n                }\n\n                return {\n                    ...layerWithComputedProperties,\n                    data: computedPoints.map(point => {\n                        point.layerLabel = layerWithComputedProperties.label\n                        point.color = layerWithComputedProperties.color\n\n                        return point\n                    }),\n                }\n            }),\n        [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]\n    )\n\n    const slices: StreamSliceData[] = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => layer.data[i])\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].data[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const layerContext: StreamCustomLayerProps = useMemo(\n        () => ({\n            xScale,\n            yScale,\n            layers: enhancedLayers,\n            slices,\n        }),\n        [xScale, yScale, enhancedLayers, slices]\n    )\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    }\n}\n", "import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps, WithChartRef } from '@nivo/core'\nimport { StreamDatum, StreamSvgProps } from './types'\nimport { Stream } from './Stream'\n\nexport const ResponsiveStream = forwardRef(\n    <RawDatum extends StreamDatum>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: ResponsiveProps<StreamSvgProps<RawDatum>>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }) => (\n                <Stream<RawDatum> {...props} width={width} height={height} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <RawDatum extends StreamDatum>(\n    props: WithChartRef<ResponsiveProps<StreamSvgProps<RawDatum>>, SVGSVGElement>\n) => ReactElement\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBO,IAAMA,KAAc,SAAHC,IAAAA;AAOU,MAN9BC,KAAKD,GAALC,OACAC,KAAWF,GAAXE,aACAC,KAAWH,GAAXG,aACAC,IAAcJ,GAAdI,gBACAC,IAAaL,GAAbK,eACAC,IAAON,GAAPM,SAEAC,IAA8CC,GAAAA,GAAtCC,IAAoBF,EAApBE,sBAAsBC,IAAWH,EAAXG,aACxBC,QAAmBC,aAAAA,aACrB,SAACC,IAAAA;AACGJ,UAAqBK,aAAAA,eAAcR,GAAS,EAAEL,OAAAA,GAAAA,CAAAA,GAAUY,IAAO,MAAA;EAClE,GACD,CAACJ,GAAsBH,GAASL,EAAAA,CAAAA,GAGpCc,IAA0CC,GAAAA,GAAlCC,IAAOF,EAAPE,SAAiBC,IAAYH,EAApBI,QACXC,IAAeC,GAAgBpB,GAAMqB,IAAAA,GACrCC,IAAgBC,UAAU,EAC5BC,OAAOxB,GAAMwB,OACbN,QAAQD,GACRQ,WAAAA,CAAYT,EAAAA,CAAAA;AAGhB,aACIU,mBAAAA,KAACC,SAASN,MAAI,EACVO,GAAGT,GACHU,MAAM7B,GAAM6B,OAAO7B,GAAM6B,OAAOP,EAAcE,OAC9CvB,aAAaA,IACb6B,QAAQ3B,EAAeH,EAAAA,GACvB+B,aAAa7B,IACb8B,aAAa5B,IAAgBM,IAAAA,QAC7BuB,cAAc7B,IAAgBM,IAAAA,QAC9BwB,cAAc9B,IAAgBK,IAAAA,OAAc0B,CAAAA;AAGxD;AApCO,ICHMC,KAAe,SAAHrC,IAAAA;AAAA,MACrBsC,KAAMtC,GAANsC,QACApC,KAAWF,GAAXE,aACAC,KAAWH,GAAXG,aACAC,KAAcJ,GAAdI,gBACAC,KAAaL,GAAbK,eACAC,IAAON,GAAPM;AAAO,aAEPqB,mBAAAA,KAAA,KAAA,EAAAY,UACKD,GAAOE,IAAI,SAACvC,IAAOwC,IAAAA;AAAC,eACjBd,mBAAAA,KAAC5B,IAAW,EAERE,OAAOA,IACPG,gBAAgBA,IAChBD,aAAaA,IACbD,aAAaA,IACbG,eAAeA,IACfC,SAASA,EAAAA,GANJmC,EAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AASb;ADjBD,IEDDC,IAAU,SACZC,IACAC,IAAAA;AAEA,MAAIC,KAAIF,GAAMG;AAOd,SANiB,aAAbF,KACAC,KAAIF,GAAMI,MAAMJ,GAAMG,KAAKH,GAAMI,MAAM,IACnB,YAAbH,OACPC,KAAIF,GAAMI,KAGPF;AACX;AFXO,IEaMG,KAAa,SAAHhD,IAAAA;AAAA,MACnBiD,KAAIjD,GAAJiD,MACAC,KAAYlD,GAAZkD,cACAN,KAAQ5C,GAAR4C,UACAO,KAAOnD,GAAPmD,SACAC,IAAQpD,GAARoD,UACAC,IAAcrD,GAAdqD,gBACAjD,IAAcJ,GAAdI;AAAc,aAEduB,mBAAAA,KAAA2B,mBAAAA,UAAA,EAAAf,UACKU,GAAKT,IAAI,SAACG,IAAOF,IAAAA;AACd,eAAO3B,aAAAA,eAAcoC,IAAc,EAC/BK,KAAKd,IACLE,OAAAA,IACAa,GAAGb,GAAMa,GACTX,GAAGH,EAAkBC,IAAOC,EAAAA,GAC5Ba,MAAMN,GAAQR,EAAAA,GACdlB,OAAO2B,EAAST,EAAAA,GAChBxC,aAAakD,EAAeV,EAAAA,GAC5Be,aAAatD,EAAeuC,EAAAA,EAAAA,CAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAGrC;AFnCA,IGNMgB,IAAmB,SAAH3D,IAAAA;AAIU,MAHnC4D,KAAK5D,GAAL4D,OACAC,KAAM7D,GAAN6D,QACAvD,IAAON,GAAPM,SAEAwD,QAA8BC,aAAAA,UAAAA,KAAS,GAAhCC,IAAOF,EAAA,CAAA,GAAEG,IAAUH,EAAA,CAAA,GAC1BvD,IAA8CC,GAAAA,GAAtCC,IAAoBF,EAApBE,sBAAsBC,IAAWH,EAAXG,aAExBC,QAAmBC,aAAAA,aACrB,SAACC,IAAAA;AACGoD,MAAAA,IAAW,GACXxD,MAAqBK,aAAAA,eAAcR,GAAS,EAAEsD,OAAAA,GAAAA,CAAAA,GAAU/C,IAAO,MAAA;EAClE,GACD,CAACoD,GAAYxD,GAAsBH,GAASsD,EAAAA,CAAAA,GAG1CM,QAAmBtD,aAAAA,aAAY,WAAA;AACjCqD,MAAAA,KAAW,GACXvD,EAAAA;EACJ,GAAG,CAACuD,GAAYvD,CAAAA,CAAAA;AAEhB,aACIyD,mBAAAA,MAAA,KAAA,EAAGC,WAAwBR,eAAAA,GAAMJ,IAAQ,QAAAjB,UAAA,CACpCyB,SACGrC,mBAAAA,KAAA,QAAA,EACI0C,IAAI,GACJC,IAAI,GACJvB,IAAI,GACJD,IAAIe,IACJ9B,QAAO,QACPwC,eAAe,MACfvC,aAAa,EAAA,CAAA,OAGrBL,mBAAAA,KAAA,QAAA,EACI6B,GAAAA,KACAgB,OAAO,IACPX,QAAQA,IACR/B,MAAK,QACL5B,aAAa,GACbgC,cAAcvB,GACdsB,aAAatB,GACbwB,cAAc+B,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAI9B;AHxCO,IIPMO,KAAe,SAAHzE,IAAAA;AAAA,MACrB0E,KAAM1E,GAAN0E,QACAb,KAAM7D,GAAN6D,QACAvD,KAAON,GAAPM;AAAO,aAEPqB,mBAAAA,KAAA,KAAA,EAAAY,UACKmC,GAAOlC,IAAI,SAAAoB,IAAAA;AAAK,eACbjC,mBAAAA,KAACgC,GAAgB,EAEbC,OAAOA,IACPC,QAAQA,IACRvD,SAASA,GAAAA,GAHJsD,GAAMe,KAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAMnB;AJPD,IKVMC,IAAe,EACxBC,OAAO,MACPC,OAAO,QACPC,YAAY,UACZC,OAAO,cACPC,SAAS,MACTC,WAAW,MACXC,YAAY,CAAE,GACdC,UAAU,CAAE,GACZC,aAAAA,OACAC,aAAAA,MACAC,QAAQ,EAAEC,QAAQ,OAAA,GAClBtF,aAAa,GACbC,aAAa,GACbuD,aAAa,EACT+B,MAAM,SACNC,WAAW,CAAC,CAAC,UAAU,CAAA,CAAA,EAAA,GAE3BC,YAAAA,OACAC,aAAa,UACb1C,cCd0B,SAAHlD,IAAAA;AAOA,MANvBwD,KAACxD,GAADwD,GACAX,KAAC7C,GAAD6C,GACAY,KAAIzD,GAAJyD,MACAhC,KAAKzB,GAALyB,OACAtB,KAAWH,GAAXG,aACAuD,IAAW1D,GAAX0D,aAEA3C,IAA0CC,GAAAA,GAAlCC,IAAOF,EAAPE,SAAiBC,IAAYH,EAApBI,QACXI,IAAgBC,UAAU,EAC5BgC,GAAAA,IACAX,GAAAA,IACAgD,QAAe,MAAPpC,IACRhC,OAAAA,IACAN,QAAQD,GACRQ,WAAAA,CAAYT,EAAAA,CAAAA;AAGhB,aACIU,mBAAAA,KAACC,SAASkE,QAAM,EACZC,IAAIxE,EAAciC,GAClBwC,IAAIzE,EAAcsB,GAClBoD,GAAG1E,EAAcsE,QACjB/D,MAAMP,EAAcE,OACpBO,aAAa7B,IACb4B,QAAQ2B,EAAAA,CAAAA;AAGpB,GDbIwC,SAAS,GACTC,UAAU,EAAEV,MAAM,QAAA,GAClBW,gBAAgB,GAChBC,gBAAgB,EAAEZ,MAAM,QAAA,GACxBpF,eAAAA,MACAC,SE7BwB,SAAHN,IAAAA;AAAA,MAAMC,KAAKD,GAALC;AAAK,aAChC0B,mBAAAA,KAAC2E,GAAY,EAACC,IAAItG,GAAM4E,OAAO2B,YAAAA,MAAkB/E,OAAOxB,GAAMwB,MAAAA,CAAAA;AAAS,GF6BvEgF,oBAAAA,MACAC,cG9BwB,SAAH1G,IAAAA;AAAqC,MAA/B4D,KAAK5D,GAAL4D,OACrB+C,SAAOC,aAAAA,SACT,WAAA;AAAA,WACIhD,GAAMiD,MAAMrE,IAAI,SAAAsE,IAAAA;AAAC,aAAI,KACjBnF,mBAAAA,KAACoF,GAAI,EAAiBtF,OAAOqF,GAAErF,MAAAA,GAApBqF,GAAEE,OAAAA,GACbF,GAAEG,YACFH,GAAEI,cAAAA;IAAAA,CAAAA;EAAAA,GAEV,CAACtD,EAAAA,CAAAA;AAGL,aAAOjC,mBAAAA,KAACwF,GAAY,EAACR,MAAMA,GAAAA,CAAAA;AAC/B,GHmBIS,SAAS,CAAA,GACTC,aAAa,MACbC,MAAM,cAAA;ALrBH,IKwBMC,IAAeC,EAAAA,CAAAA,GACrB5C,GAAY,EACftC,QAAQ,CAAC,QAAQ,QAAQ,UAAU,QAAQ,UAAU,SAAA,GACrDmF,MAAM,CAAA,GACN3F,MAAM,CAAA,GACNb,SAAAA,MACAyG,cAAc,WACdJ,MAAM,OACNK,aAAAA,MAAa,CAAA;ALhCV,IKgCU,IAAA,CAAA,iBAAA,WAAA,gBAAA,SAAA,eAAA;ALhCV,ISSDC,IAAc,SAAH5H,IAAAA;AAyCiB,MAxC9BiD,KAAIjD,GAAJiD,MACA4E,KAAI7H,GAAJ6H,MACAhD,IAAK7E,GAAL6E,OACAiD,IAAW9H,GAAX8H,aACA/C,IAAU/E,GAAV+E,YACAD,IAAK9E,GAAL8E,OACAE,IAAKhF,GAALgF,OAAK+C,IAAA/H,GACLsC,QAAQ0F,IAAAA,WAAWD,IAAGR,EAAgBjF,SAAMyF,GAC5CvD,IAAKxE,GAALwE,OACAX,IAAM7D,GAAN6D,QACQoE,KAAajI,GAArBkI,QACAjD,KAAOjF,GAAPiF,SACAC,KAASlF,GAATkF,WAASiD,KAAAnI,GACTmF,YAAAA,KAAAA,WAAUgD,KAAGZ,EAAgBpC,aAAUgD,IAAAC,KAAApI,GACvCoF,UAAAA,KAAAA,WAAQgD,KAAGb,EAAgBnC,WAAQgD,IAAAC,KAAArI,GACnCqF,aAAAA,KAAAA,WAAWgD,KAAGd,EAAgBlC,cAAWgD,IAAAC,KAAAtI,GACzCsF,aAAAA,KAAAA,WAAWgD,KAAGf,EAAgBjC,cAAWgD,IACzC/C,KAAMvF,GAANuF,QAAMgD,IAAAvI,GACNE,aAAAA,KAAAA,WAAWqI,IAAGhB,EAAgBrH,cAAWqI,GAAAC,KAAAxI,GACzCG,aAAAA,KAAAA,WAAWqI,KAAGjB,EAAgBpH,cAAWqI,IACzC9E,KAAW1D,GAAX0D,aAAW+E,KAAAzI,GACXyH,MAAAA,KAAAA,WAAIgB,KAAGlB,EAAgBE,OAAIgB,IAAAC,KAAA1I,GAC3B8B,MAAAA,KAAAA,WAAI4G,KAAGnB,EAAgBzF,OAAI4G,IAAAC,KAAA3I,GAC3B2F,YAAAA,KAAAA,WAAUgD,KAAGpB,EAAgB5B,aAAUgD,IAAAC,KAAA5I,GACvC4F,aAAAA,KAAAA,WAAWgD,KAAGrB,EAAgB3B,cAAWgD,IAAAC,KAAA7I,GACzCkD,cAAAA,KAAAA,WAAY2F,KAAGtB,EAAgBrE,eAAY2F,IAC3C3C,KAAOlG,GAAPkG,SACAC,KAAQnG,GAARmG,UACAC,KAAcpG,GAAdoG,gBACAC,KAAcrG,GAAdqG,gBAAcyC,KAAA9I,GACdK,eAAAA,KAAAA,WAAayI,KAAGvB,EAAgBlH,gBAAayI,IAAAC,KAAA/I,GAC7CM,SAAAA,KAAAA,WAAOyI,KAAGxB,EAAgBjH,UAAOyI,IAAAC,KAAAhJ,GACjCyG,oBAAAA,KAAAA,WAAkBuC,KAAGzB,EAAgBd,qBAAkBuC,IAAAC,KAAAjJ,GACvD0G,cAAAA,KAAAA,WAAYuC,KAAG1B,EAAgBb,eAAYuC,IAAAC,KAAAlJ,GAC3CoH,SAAAA,KAAAA,WAAO8B,KAAG3B,EAAgBH,UAAO8B,IACjC5B,KAAItH,GAAJsH,MACA6B,KAASnJ,GAATmJ,WACAC,KAAcpJ,GAAdoJ,gBACAC,KAAerJ,GAAfqJ,iBACAC,KAAYtJ,GAAZsJ,cAEAC,KAAqEC,GACjEhF,GACAX,GACAoE,EAAAA,GAHIC,KAAMqB,GAANrB,QAAQuB,KAAUF,GAAVE,YAAYC,KAAWH,GAAXG,aAAaC,KAAUJ,GAAVI,YAAYC,KAAWL,GAAXK,aAMrDC,KChDqB,SAAH7J,IAAAA;AAgChB,QA/BFwE,KAAKxE,GAALwE,OACAX,KAAM7D,GAAN6D,QACAZ,KAAIjD,GAAJiD,MACA4E,KAAI7H,GAAJ6H,MAAIiC,KAAA9J,GACJ6E,OAAAA,KAAAA,WAAKiF,KAAGlF,EAAaC,QAAKiF,IAC1BhC,KAAW9H,GAAX8H,aAAWiC,IAAA/J,GACX+E,YAAAA,IAAAA,WAAUgF,IAAGnF,EAAaG,aAAUgF,GAAAC,IAAAhK,GACpC8E,OAAAA,KAAAA,WAAKkF,IAAGpF,EAAaE,QAAKkF,GAAAC,IAAAjK,GAC1BgF,OAAAA,IAAAA,WAAKiF,IAAGrF,EAAaI,QAAKiF,GAAAC,IAAAlK,GAC1BuF,QAAAA,KAAAA,WAAM2E,IAAGtF,EAAaW,SAAM2E,GAAAC,KAAAnK,GAC5B0D,aAAAA,KAAAA,WAAWyG,KAAGvF,EAAalB,cAAWyG,IAAAC,KAAApK,GACtCkG,SAAAA,KAAAA,WAAOkE,KAAGxF,EAAasB,UAAOkE,IAAAC,KAAArK,GAC9BmG,UAAAA,KAAAA,WAAQkE,KAAGzF,EAAauB,WAAQkE,IAAAC,KAAAtK,GAChCoG,gBAAAA,KAAAA,WAAckE,KAAG1F,EAAawB,iBAAckE,IAAAC,KAAAvK,GAC5CqG,gBAAAA,KAAAA,WAAckE,KAAG3F,EAAayB,iBAAckE,IAkBtCC,KAAmBC,GAAsBzF,CAAAA,GACzC0F,SAAgB9D,aAAAA,SAClB,WAAA;AAAA,aACI+D,aAAAA,EACKnH,EAAE,SAAAoH,IAAAA;AAAI,eAAAA,GAADpH;MAAS,CAAA,EACdqH,GAAG,SAAAC,IAAAA;AAAK,eAAAA,GAAF/H;MAAW,CAAA,EACjBA,GAAG,SAAAgI,IAAAA;AAAK,eAAAA,GAAFjI;MAAW,CAAA,EACjBkC,MAAMwF,EAAAA;IAAAA,GACf,CAACA,EAAAA,CAAAA,GAGC3D,SAAQD,aAAAA,SACV,WAAA;AAAA,aACIoE,cAAAA,EACKnD,KAAKA,EAAAA,EACLoD,OAAOC,GAAoBnG,CAAAA,CAAAA,EAC3BD,MAAMqG,GAAmBrG,EAAAA,CAAAA;IAAO,GACzC,CAAC+C,IAAM9C,GAAYD,EAAAA,CAAAA,GAGvBsG,SAAiCxE,aAAAA,SAAQ,WAAA;AACrC,UAAMyE,KAAmB,CAAA,GACnBC,KAAmB,CAAA,GAEnBhJ,KAASuE,GAAM5D,EAAAA,EAAMT,IAAI,SAAAvC,IAAAA;AAC3B,eAAOA,GAAMuC,IAAI,SAAA+I,IAAAA;AAIb,iBAHAF,GAAOG,KAAKD,GAAM,CAAA,CAAA,GAClBD,GAAOE,KAAKD,GAAM,CAAA,CAAA,GAElB/D,EAAAA,CAAAA,GACO+D,IAAK,EACRE,OAAOF,GAAMtI,KAAKhD,GAAMsD,GAAAA,EAAAA,CAAAA;QAEhC,CAAA;MACJ,CAAA,GAEMmI,KAAWC,KAAKC,IAAGC,MAARF,MAAYN,EAAAA,GACvBS,KAAWH,KAAKI,IAAGF,MAARF,MAAYL,EAAAA;AAa7B,aAAO,CAAChJ,IAXO0J,EACX,EAAEC,MAAM,QAAA,GACR,EAAEC,KAAKC,MAAM1G,KAAK,EAAE2G,QAAQnJ,GAAKmJ,OAAAA,GAAU,SAACC,IAAG5J,IAAAA;AAAC,eAAKA;MAAAA,CAAAA,GAAImJ,KAAK,GAAGG,KAAK9I,GAAKmJ,OAAAA,GAC3E5H,EAAAA,GAEW8H,EACX,EAAEL,MAAM,UAAUL,KAAKF,GAAAA,GACvB,EAAEQ,KAAK,CAACR,IAAUI,EAAAA,GAAWF,KAAKF,IAAUK,KAAKD,GAAAA,GACjDjI,IACA,GAAA,CAAA;IAGP,GAAE,CAACgD,IAAO5D,IAAMuB,IAAOX,EAAAA,CAAAA,GA/BjBvB,KAAM8I,GAAA,CAAA,GAAEmB,KAAMnB,GAAA,CAAA,GAAEoB,KAAMpB,GAAA,CAAA,GAiCvBqB,KAAQC,EAAAA,GACRtJ,KAAWuJ,GACbpH,IACA,IAAA,GAEEnF,KAAiBwM,GAAmClJ,IAAa+I,EAAAA,GAEjEI,SAAajG,aAAAA,SACf,WAAA;AAAA,aAA0B,cAAA,OAAZV,KAAyBA,KAAU,WAAA;AAAA,eAAMA;MAAO;IAAA,GAC9D,CAACA,EAAAA,CAAAA,GAEC4G,KAAcF,GAAkBzG,IAAUsG,EAAAA,GAC1CM,SAAoBnG,aAAAA,SACtB,WAAA;AAAA,aAAiC,cAAA,OAAnBR,KAAgCA,KAAiB,WAAA;AAAA,eAAMA;MAAc;IAAA,GACnF,CAACA,EAAAA,CAAAA,GAEC4G,MAAoBJ,GAAkBvG,IAAgBoG,EAAAA,GAEtDQ,MAAWC,GAGfrI,EAAAA,GACIsI,MAAcC,GAAkBtF,EAAAA,GAEhCuF,UAAoCzG,aAAAA,SACtC,WAAA;AAAA,aACItE,GAAOE,IAAI,SAAC8K,IAAQC,IAAAA;AAChB,YAAMC,KAAqCF,GAAO9K,IAAI,SAAC+I,IAAO9I,IAAAA;AAAC,iBAAM,EACjEuE,SAASa,GAAK0F,EAAAA,GACdtG,YAAY,IACZtC,OAAOlC,IACPhB,OAAO,IACP+B,GAAG+I,GAAO9J,EAAAA,GACVgJ,OAAOF,GAAME,OACbvE,gBAAgBiG,IAAY5B,GAAME,KAAAA,GAClC1I,IAAIyJ,GAAOjB,GAAM,CAAA,CAAA,GACjBzI,IAAI0J,GAAOjB,GAAM,CAAA,CAAA,EAAA;QACpB,CAAA,GAEKtL,KAA2D,EAC7DsG,IAAIsB,GAAK0F,EAAAA,GACTjM,MAAMoJ,GAAc8C,EAAAA,EAAAA,GAGlBC,KAA0DjG,EAAA,CAAA,GACzDvH,IAAK,EACR4E,OAAOoI,IAAShN,EAAAA,GAChBwB,OAAO2B,GAASnD,EAAAA,EAAAA,CAAAA;AAGpB,eAAAuH,EAAAA,CAAAA,GACOiG,IAA2B,EAC9BxK,MAAMuK,GAAehL,IAAI,SAAA+I,IAAAA;AAIrB,iBAHAA,GAAMtE,aAAawG,GAA4B5I,OAC/C0G,GAAM9J,QAAQgM,GAA4BhM,OAEnC8J;QAAAA,CAAAA,EAAAA,CAAAA;MAGnB,CAAA;IAAE,GACN,CAACjJ,IAAQuF,IAAMoF,KAAUvC,IAAetH,IAAUmJ,IAAQC,IAAQW,GAAAA,CAAAA,GAGhEzI,UAA4BkC,aAAAA,SAC9B,WAAA;AAAA,aACIuF,MAAM1G,KAAK,EAAE2G,QAAQnJ,GAAKmJ,OAAAA,GAAU,SAACC,IAAG5J,IAAAA;AACpC,YAAMiL,KAAaL,IACd7K,IAAI,SAAAvC,IAAAA;AAAK,iBAAIA,GAAMgD,KAAKR,EAAAA;QAAE,CAAA,EAC1BkL,KAAK,SAACC,IAAGC,IAAAA;AAAC,iBAAKD,GAAE9K,KAAK+K,GAAE/K;QAAAA,CAAAA;AAE7B,eAAO,EACH6B,OAAOlC,IACPe,GAAG6J,IAAe,CAAA,EAAGpK,KAAKR,EAAAA,EAAGe,GAC7BqD,OAAO6G,GAAAA;MAEf,CAAA;IAAE,GACN,CAACzK,GAAKmJ,QAAQiB,GAAAA,CAAAA,GAGZS,UAAuClH,aAAAA,SACzC,WAAA;AAAA,aAAO,EACH2F,QAAAA,IACAC,QAAAA,IACAlK,QAAQ+K,KACR3I,QAAAA,IAAAA;IACF,GACF,CAAC6H,IAAQC,IAAQa,KAAgB3I,GAAAA,CAAAA;AAGrC,WAAO,EACH6H,QAAAA,IACAC,QAAAA,IACAlK,QAAQ+K,KACR3I,QAAAA,KACAtE,gBAAAA,IACAyM,YAAAA,IACAC,aAAAA,IACAC,mBAAAA,IACAC,mBAAAA,KACAc,cAAAA,IAAAA;EAER,EDhI4B,EACpBtJ,OAAOiF,IACP5F,QAAQ6F,IACRzG,MAAAA,IACA4E,MAAAA,IACAhD,OAAAA,GACAiD,aAAAA,GACA/C,YAAAA,GACAD,OAAAA,GACAE,OAAAA,GACAO,QAAAA,IACA7B,aAAAA,IACAwC,SAAAA,IACAC,UAAAA,IACAC,gBAAAA,IACAC,gBAAAA,GAAAA,CAAAA,GAzBAkG,KAAM1C,GAAN0C,QACAC,KAAM3C,GAAN2C,QACAlK,KAAMuH,GAANvH,QACAoC,MAAMmF,GAANnF,QACAtE,KAAcyJ,GAAdzJ,gBACAyM,KAAUhD,GAAVgD,YACAC,KAAWjD,GAAXiD,aACAC,KAAiBlD,GAAjBkD,mBACAC,KAAiBnD,GAAjBmD,mBACAc,KAAYjE,GAAZiE,cAmBEC,KAAYC,GAASvG,IAAMnF,IAAQR,EAAAA,GAEnCmM,KAA8C,EAChDC,MAAM,MACNC,MAAM,MACN7L,QAAQ,MACR8L,MAAM,MACN1J,QAAQ,MACR0C,SAAS,KAAA;AAwGb,SArGIY,EAAYqG,SAAS,MAAA,MACrBJ,GAAUC,WACNvM,mBAAAA,KAAC2M,GAAI,EAED9J,OAAOiF,IACP5F,QAAQ6F,IACR6C,QAAQlH,KAAckH,KAAS,MAC/BC,QAAQlH,KAAckH,KAAS,KAAA,GAJ3B,MAAA,IASZxE,EAAYqG,SAAS,MAAA,MACrBJ,GAAUE,WACNxM,mBAAAA,KAAC4M,GAAI,EAEDhC,QAAQA,IACRC,QAAQA,IACRhI,OAAOiF,IACP5F,QAAQ6F,IACR8E,KAAKvJ,IACLwJ,OAAOvJ,IACPwJ,QAAQvJ,IACRwJ,MAAMvJ,GAAAA,GARF,MAAA,IAaZ4C,EAAYqG,SAAS,QAAA,MACrBJ,GAAU3L,aACNX,mBAAAA,KAACU,IAAY,EAETC,QAAQA,IACRpC,aAAaA,IACbC,aAAaA,IACbC,gBAAgBA,IAChBC,eAAeA,IACfC,SAASA,GAAAA,GANL,QAAA,IAWZ0H,EAAYqG,SAAS,MAAA,KAAW1I,OAChCsI,GAAUG,WACNzM,mBAAAA,KAACiN,aAAAA,UAAQ,EAAArM,UACJD,GAAOE,IAAI,SAAAvC,IAAAA;AAAK,eACb0B,mBAAAA,KAACqB,IAAU,EAEPuD,IAAItG,GAAMsG,IACV9E,OAAOxB,GAAMwB,OACbwB,MAAMhD,GAAMgD,MACZC,cAAcA,IACdN,UAAUgD,IACVzC,SAAS0J,IACTzJ,UAAU0J,IACVzJ,gBAAgB0J,IAChB3M,gBAAgB4M,GAAAA,GATX/M,GAAMsG,EAAAA;EAAAA,CAAAA,EAAAA,GAHT,MAAA,IAmBlByB,EAAYqG,SAAS,QAAA,KAAahO,MAAiBoG,OACnDwH,GAAUvJ,aACN/C,mBAAAA,KAAC8C,IAAY,EAETC,QAAQA,KACRb,QAAQ6F,IACRpJ,SAASoG,GAAAA,GAHL,QAAA,IAQZsB,EAAYqG,SAAS,SAAA,MACrBJ,GAAU7G,cACNzF,mBAAAA,KAACiN,aAAAA,UAAQ,EAAArM,UACJ6E,GAAQ5E,IAAI,SAACqM,IAAQpM,IAAAA;AAClB,QAAMqM,KAAaxM,GACdE,IAAI,SAAAvC,IAAAA;AAAK,aAAK,EACXsG,IAAItG,GAAMsG,IACV1B,OAAO5E,GAAM4E,OACbpD,OAAOxB,GAAMwB,OACbK,MAAM7B,GAAM6B,KAAAA;IACf,CAAA,EACAiN,QAAAA;AAEL,eACIpN,mBAAAA,KAACqN,IAAYxH,EAAAA,CAAAA,GAELqH,IAAM,EACVI,gBAAgBxF,IAChByF,iBAAiBxF,IACjBzG,MAAM6L,GAAAA,CAAAA,GAJDrM,EAAAA;EAAAA,CAAAA,EAAAA,GAbP,SAAA,QA0BlBd,mBAAAA,KAACwN,IAAU,EACP3K,OAAOmF,IACP9F,QAAQ+F,IACR1B,QAAQA,IACRT,MAAMsG,IACNzG,MAAMA,IACN6B,WAAWA,IACXC,gBAAgBA,IAChBC,iBAAiBA,IACjB+F,KAAK9F,IAAa/G,UAEjByF,EAAYxF,IAAI,SAACvC,IAAOwC,IAAAA;AAAM,QAAA4M;AAC3B,WAAqB,cAAA,OAAVpP,SACA0B,mBAAAA,KAACiN,aAAAA,UAAQ,EAAArM,cAAUzB,aAAAA,eAAcb,IAAO6N,EAAAA,EAAAA,GAAzBrL,EAAAA,IAGD,SAAzB4M,KAAOpB,QAAAA,KAAAA,SAAAA,GAAYhO,EAAAA,KAAMoP,KAAI;EAAA,CAAA,EAAA,CAAA;AAI7C;AT3NO,IS6NMC,QAASC,aAAAA,YAClB,SAAA3E,IASIwE,IAAAA;AAAuB,MAAAI,KAAA5E,GAPnBvK,eAAAA,KAAAA,WAAamP,KAAGjI,EAAgBlH,gBAAamP,IAAAC,KAAA7E,GAC7C3J,SAAAA,KAAAA,WAAOwO,KAAGlI,EAAgBtG,UAAOwO,IAAAC,IAAA9E,GACjClD,cAAAA,IAAAA,WAAYgI,IAAGnI,EAAgBG,eAAYgI,GAC3CjD,IAAK7B,GAAL6B,OACAkD,IAAa/E,GAAb+E,eACGC,IAAKC,EAAAjF,IAAAkF,CAAAA;AAAA,aAIZnO,mBAAAA,KAACoO,IAAS,EACN9O,SAASA,IACTZ,eAAeA,IACfqH,cAAcA,GACdiI,eAAeA,GACflD,OAAOA,GAAMlK,cAEbZ,mBAAAA,KAACiG,GAAWJ,EAAAA,CAAAA,GAAeoI,GAAK,EAAEvP,eAAeA,IAAeiJ,cAAc8F,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACtE,CAAA;ATjPb,ISiPa,IAAA,CAAA,gBAAA,iBAAA,YAAA,gBAAA;ATjPb,IWXMY,QAAmBT,aAAAA,YAC5B,SAAAvP,IAQIoP,IAAAA;AAAuB,MANnBa,KAAYjQ,GAAZiQ,cACAC,KAAalQ,GAAbkQ,eACAC,KAAQnQ,GAARmQ,UACAC,KAAcpQ,GAAdoQ,gBACGR,IAAKC,EAAA7P,IAAA8P,CAAAA;AAAA,aAIZnO,mBAAAA,KAAC0O,IAAiB,EACdJ,cAAcA,IACdC,eAAeA,IACfC,UAAUA,IACVC,gBAAgBA,IAAe7N,UAE9B,SAAAqI,IAAAA;AAAA,QAAGpG,KAAKoG,GAALpG,OAAOX,KAAM+G,GAAN/G;AAAM,eACblC,mBAAAA,KAAC2N,GAAM9H,EAAAA,CAAAA,GAAeoI,GAAK,EAAEpL,OAAOA,IAAOX,QAAQA,IAAQuL,KAAKA,GAAAA,CAAAA,CAAAA;EAAO,EAAA,CAAA;AAE3D,CAAA;",
  "names": ["StreamLayer", "_ref", "layer", "fillOpacity", "borderWidth", "getBorderColor", "isInteractive", "tooltip", "_useTooltip", "useTooltip", "showTooltipFromEvent", "hideTooltip", "handleMouseHover", "useCallback", "event", "createElement", "_useMotionConfig", "useMotionConfig", "animate", "springConfig", "config", "animatedPath", "useAnimatedPath", "path", "animatedProps", "useSpring", "color", "immediate", "_jsx", "animated", "d", "fill", "stroke", "strokeWidth", "onMouseMove", "onMouseEnter", "onMouseLeave", "undefined", "StreamLayers", "layers", "children", "map", "i", "getDotY", "datum", "position", "y", "y2", "y1", "StreamDots", "data", "dotComponent", "getSize", "getColor", "getBorderWidth", "_Fragment", "key", "x", "size", "borderColor", "StreamSlicesItem", "slice", "height", "_useState", "useState", "isHover", "setIsHover", "handleMouseLeave", "_jsxs", "transform", "x1", "x2", "strokeOpacity", "width", "StreamSlices", "slices", "index", "defaultProps", "label", "order", "offsetType", "curve", "axisTop", "axisRight", "axisBottom", "axisLeft", "enableGridX", "enableGridY", "colors", "scheme", "from", "modifiers", "enableDots", "dotPosition", "radius", "circle", "cx", "cy", "r", "dotSize", "dotColor", "dotBorderWidth", "dotBorderColor", "BasicTooltip", "id", "enableChip", "enableStackTooltip", "stackTooltip", "rows", "useMemo", "stack", "p", "Chip", "layerId", "layerLabel", "formattedValue", "TableTooltip", "legends", "legendLabel", "role", "svgDefaultProps", "_extends", "defs", "motionConfig", "isFocusable", "InnerStream", "keys", "valueFormat", "_ref$layers", "chartLayers", "partialMargin", "margin", "_ref$axisBottom", "_ref$axisLeft", "_ref$enableGridX", "_ref$enableGridY", "_ref$fillOpacity", "_ref$borderWidth", "_ref$defs", "_ref$fill", "_ref$enableDots", "_ref$dotPosition", "_ref$dotComponent", "_ref$isInteractive", "_ref$tooltip", "_ref$enableStackToolt", "_ref$stackTooltip", "_ref$legends", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "forwardedRef", "_useDimensions", "useDimensions", "innerWidth", "innerHeight", "outerWidth", "outerHeight", "_useStream", "_ref$label", "_ref$offsetType", "_ref$order", "_ref$curve", "_ref$colors", "_ref$borderColor", "_ref$dotSize", "_ref$dotColor", "_ref$dotBorderWidth", "_ref$dotBorderColor", "areaCurveFactory", "useCurveInterpolation", "areaGenerator", "area", "_ref2", "y0", "_ref3", "_ref4", "d3Stack", "offset", "stackOffsetFromProp", "stackOrderFromProp", "_useMemo", "allMin", "allMax", "point", "push", "value", "minValue", "Math", "min", "apply", "maxValue", "max", "createPointScale", "type", "all", "Array", "length", "_", "createLinearScale", "xScale", "yScale", "theme", "useTheme", "useOrdinalColorScale", "useInheritedColor", "getDotSize", "getDotColor", "getDotBorderWidth", "getDotBorderColor", "getLabel", "usePropertyAccessor", "formatValue", "useValueFormatter", "enhancedLayers", "points", "layerIndex", "computedPoints", "layerWithComputedProperties", "sliceStack", "sort", "a", "b", "layerContext", "boundDefs", "bindDefs", "layerById", "grid", "axes", "dots", "includes", "Grid", "Axes", "top", "right", "bottom", "left", "Fragment", "legend", "legendData", "reverse", "BoxLegendSvg", "containerWidth", "containerHeight", "SvgWrapper", "ref", "_layerById$layer", "Stream", "forwardRef", "_ref2$isInteractive", "_ref2$animate", "_ref2$motionConfig", "renderWrapper", "props", "_objectWithoutPropertiesLoose", "_excluded", "Container", "ResponsiveStream", "defaultWidth", "defaultHeight", "onResize", "debounceResize", "ResponsiveWrapper"]
}
